A “design document” for your project in the form of a Markdown file called DESIGN.md that discusses, technically, how you implemented your project and why you made the design decisions you did. Your design document should be at least several paragraphs in length. Whereas your documentation is meant to be a user’s manual, consider your design document your opportunity to give the staff a technical tour of your project underneath its hood.

PROJECT NAME: Yalieats

Languages, Scripts, and Framewords Used: Python, Flask, HTML, Jinja, CSS, and SQL (SQLite3)

TABLE OF CONTENTS:
1) BRIEF PROJECT DESCRIPTION
2) APP.PY DESCRIPTION
3) STATIC FOLDER DETAIL
4) TEMPLATES FOLDER DETAIL
5) HELPERS.PY DETAIL
6) REQUIREMENTS.TXT DETAIL
7) YALIEATS.DB DETAIL
8) SECURITY DETAIL
9) CONCLUSION

BRIEF PROJECT DESCRIPTION (technical): Yalieats is a Flask application that was built, tested, and run entirely in the CS50 VSCode IDE (the browser version, not the desktop version) that has been utilized during the semester as the key virtual codespace for Yale's CS50 course. All the accompanying files are included in the finalproject folder, which includes a flask_session folder, a static folder that contains images (.jpeg, .png), favicons(.ico), fonts(.otf), and styles.css found in the application, a templates folder that contains all of the html files, the app.py file, the DESIGN.md and README.md files, a helpers.py file, a requirements.txt file, and the yalieats.db database (SQLite3), which includes a table for the members, a table for the restaurants, and a table for the reviews. The app.py integrates the Flask and the Python to make the magic happen underneath the hood and renders the results of SQL queries through HTML pages that integrate both Jinja and CSS to get the design and functionality exactly what it should be and what it appears as when the application is running.


The following sections will go through the contents of the finalproject folder. The documentation begins with the app.py file.

The app.py file (each @app.route in the file), the heart of the application, that integrates the Python code, the Flask framework, the SQL database information, and the HTML/CSS frontend content.

APP.PY DESCRIPTION

1) Lines 1-6 involve importing some functionalties from different libraries that are integrated into the application help with things like redirecting, rendering the HTML pages, user sessions, and security (exemplified by the password hash functions and login_required function that is imported from helpers.py)

2) Lines 8-14 involve setting up and configuring the Flask application

3) Line 16 loads in the database "yalieats.db" and assigns it to the variable db, so SQL commands in the program can call upon db to execute the directions and get information that the user is requesting or interacting with

4) Line 18 --> after_request: the after_response function simply ensures that responses are not cached.

5) Line 26 --> @app.route("/", methods=["GET"]) def home(): This route acts as a simple GET that renders the before_main.html file, which is the home page that users are initially taken to when first running the application and it acts as the starting point for users to either log in or register, which are the methods that allow the user to access the rest of the application's features

6) Line 30 --> @app.route("/register", methods=["GET", "POST"])def register(): This route takes in both GET and POST requests, which means that an if statement is used to differentiate between the two. The function starts off by checking if something was posted through the register form that appears to the user when they click the button "Register" on the before_main.html page. The function then runs through a series of validations to ensure that the form is completely filled out to ensure that registration entries are complete. The function goes field by field to check each part of the form (first name, last name, email address, username, password, and password confirmation). If any of those are missing or the passwords do not match, then the application will render an HTML file (using the render_template function) that contains an error message and tells the user what they did wrong. The user can then click a button below each message to be redirected back to the registration form. When the user sucessfully fills out the form and clicks submit, the user will be redirected back to the before_main page where they can then click "Log In", type in their newly created username and password, and access the rest of the application. In the background, the information typed into the form is inserted into the members table of the yalieats database using SQL commands (INSERT) and a series of request.form.get() commands as well as hashing the password using the generate_password_hash function. If the user is simply clicking the register button, however, then the register.html page will render with the form.

7) @app.route("/before_main", methods=["GET"]): This route is a simple GET that renders the before_main.html file. This route is integrated into the header of the page (where the Yalieats wording is at the top) so when the user clicks the big "Yalieats" before logging in, they will be redirected back to the before_main.html file.

8) @app.route("/main", methods=["GET"]) @login_required def main(): This route is one of the first to require a login to access. This @login_required is crucial because it prevents people from simply putting main at the end of the URL and accessing the page's information without logging in or creating an account. The @login_required in the future means the page requires the user to be logged in. This function renders the new main homepage that appears to users after they log in. A navigation bar is rendered and the user can now see a series of buttons that allow them to interact with the information in the restaurants and reviews tables of the yalieats database.

9) @app.route("/search_by_restaurant", methods=["GET"]) @login_required def search_by_restaurant(): Ths route is a simple GET that renders the search_by_restaurant.html file, which occurs when the user clicks on the button "Search by Restaurant". The user should now see a dropdown menu that will allow them to access information about the restaurant that they select from the menu.

10) @app.route("/reviews_static", methods=["GET"]) @login_required def reviews_static(): This route displays a dropdown menu that allows users to access the reviews for a restaurant. When the user clicks the "Get Reviews" button on the page where the restaurant information is displayed, the reviews.html page is rendered and the user will see another dropdown menu where they can choose their restaurant and see the reviews for it. The user now has the option to get reviews for the restaurant they were just looking at information more or if they change their mind, they can simply choose a different restaurant, which explains the choice to include an additional dropdown menu step.

11) @app.route("/about_us", methods=["GET"]) @login_required def about_us(): This route renders the about_us.html page, which is simply a static page that displays the Yalieats story and allows users to understand the history behind the venture.

12) @app.route("/contact_us", methods=["GET"]) @login_required def contact_us(): This route renders the contact_us.html page, which contains an embedded Google Forms survey that allows users within the Yale organization to leave feedback within the website and when they submit the form, I will then be able to access the responses using Google's Forms feature and can then implement the suggestions at a future date into the application

13) @app.route("/your_account", methods=["GET", "POST"]) @login_required def your_account(): This route takes both GET and POST arguments. The function begins by checking if the request is a POST. The POST feature is required due to the form located on this page. Since the table of review history displays restaurant IDs rather than the names to save space and redundancy within the actual table and to make compressing the table easier for mobile devices, users may want to remind themselves of what restaurant corresponds to the ID. The user can enter the ID of one of the entries in their table of personalized review history and then they will get back the name of the restaurant. The form accepts 1-212, inclusive, and if the user types in and tries to submit anything else, the form will not submit and spring a small message reminding the user of the range. If the form submission is a success, then a SQL SELECT query will be run to get the restaurant_name from restaurants at the place where the IDs match up. The name will then be accessed using the name[0]["restaurant_name"] value. Next, another SQL query is run that gathers all the current reviews that the user has. Finally, the your_account.html file is rendered with the restaurant_name and reviews passed in.
If the route is a GET, then the function will try to get the full reviews using an SELECT * SQL query where the memberID matches that of the user that is currently logged in. If this query is successful, then the reviews will be passed into the rendered your_account.html page; however, if it unsuccessful (an IndexError will show up because there is nothing to be indexed into), then it will simply render the your_empty_account.html page, which displays no reviews.

14) @app.route("/write_a_review", methods=["GET", "POST"]) @login_required def write_a_review(): This route allows users to write reviews and post them to the reviews table in the yalieats database. The function begins by checking if the request is a POST. if it is, it then checks to make sure that a restaurant name was selected from the dropdown menu. If there is no entry, it then renders a page that tells the user they are missing the restaurant name. The function will then try to execute a SQL query where it checks to see if there is a restaurant in the database that matches the one from the dropdown menu. Although it seems counterintuitive to have an erroe checker for a dropdown menu that I created, I included it to ensure that dropdown entries matched those in the database to find any errors. If there is an error, the application will then render an invalid restaurant name HTML page. The function then goes through a series of checks and verifications to ensure all fields are filled and renders an error HTML page if one is found. After all the checks are cleared, the restaurant id is acquired by running a SQL query that gets the id from the restauants at the selected restaurant_name because the restaurant ID matches the ID that will be entered into the reviews table (restaurant_id). This connection is important because it will allow the user to access the reviews that are tied to a certain restaurant ID. A new review is then added to the reviews table using an INSERT INTO SQL operation that inserts the found id, the member id (so members can see their review history), and then the rest of the information in the form. After submitting, the user is taken back to the main.html homepage. If the argument is a GET, then the review page with the blank form will be rendered on the screen.

15) @app.route("/reviews", methods=["POST"]) @login_required def reviews(): This route allows user to submit a dropdown menu form that allows them to choose a restaurant they want to see the review from. When the user clicks the See Reviews button on the results page that has the restaurant information, they are then redirected to this page where they can choose a restaurant from the dropdown menu. If no restaurant is selected and the user submits the form, an error html page will render. Next, the program will try to execute a SQL query that attempts to select the price_rating from the reviews while joining the restaurants table and the reviews table through their matching IDs to see if that certain restaurant name even has any price ratings. Since price ratings are a required part of a review, if the query returns an IndexError, that means there are no price ratings, and, therefore, no reviews. The no_reviews.html tab is then rendered, which lets the user know that there are no reviews for their selected restaurant. The next lines of code are a series of SQL commands that gather the average price_rating, average portion_size_rating, recommendation, average overall_restaurant_rating, average_deliciousness_rating, review_text, and restaurant_name. These respective values are then assigned to variables that will then be used in the bang_for_buck calculation and passed into the render_template function that will allow the values to be displayed on the HTML page using Jinja. The bang_for_buck value is a simple formula I came up with by averaging the values of portion size, price rating, and deliciousness rating to get a value that gives users an idea of how much bang they're getting for their buck. The review_result.html is then rendered with all of the revelant information being displayed in a table that is filled using Jinja and the {{}} feature.

16) @app.route("/search_for_restaurant", methods=["POST"]) @login_required def search_for_restaurant(): This route is a POST route that allows users to choose a restaurant from a dropdown menu and get information about it based on their search. The function first checks if the form is blank, and if so, it renders an HTML page with an error message. The function then executes a SQL query to see if there is a restaurant_name that matches the entry. Like mentioned previously, this may seem counterintuitive since the user is simply selecting rather than typing something in, but it ensures that on my end, I can see if the restaurants table values match those of the dropdown menu options. If there is an error, then an error HTML page is rendered. If there is no error, however, then the information about the restaurant is gathered using a series of SQL SELECT queries. The results of each of these queries are then used to get the desired piece of information (such as address, phone_number, etc.) and then those values are assigned to variables. Once all of the pertinent information has been selected from the database and assigned to variables, the variables are then passed into the render_template function and on the restaurant_result.html page, the gathered information will appear using Jinja to pass in the values. Users can then see the information from the database, but also have the option to click a button to be redirected to Google Maps with the address automatically entered, click a button to directly call the restaurant if accessing the program on a mobile device, or click a button to go to the page where users can select a restaurant to get reviews from.

17) @app.route("/filter_search", methods=["GET","POST"]) @login_required def filter_search(): This route takes in both GET and POST arguments. The function first checks if the argument is a POST. If it us, it then goes through a series of 6 if-statements that check for the different combinations of form entries in the case that the user only selects 1/3 or 2/3 form options. That decision was made to offer the user more flexibility in searching for restaurants using the filter capability. Within each of the first 6 if-statements, the if statement itself checks each of the form fields and checks for the different scenarios of each of the 3 options potentially being blank or with an option using != "" and == "". Based on the type_of_food, on_snackpass, and restaurant_vibe responses, an SQL query will then be executed based on these criteria. For example, if on the on_snackpass option has been selected where the others are blank, the program will run an SQL statement that selects the entries of the restaurants where the on_snackpass field matches that of the user selection. If there are no restaurants that match the filter combination that the user has put in, then an error HTML page will render telling the user that there are no results for their query. However, if there are matches, then the filter_search_result.html file is rendered with the restaurant entries passed in. Within the html file, a Jinja for-loop is integrated to display the restaurant information for each entry and the page length lengthens and shortens to meet the varying number of options. If all three fields are filled, however, then the program will run an SQL query with all three fields and if there are no results, then display the error message, but if there are results, then to display the results using the filter_search_result.html page and looping through the entries using a Jinja for-loop. If the route is a GET, then the page with the filters will render.

18) @app.route("/login", methods=["GET", "POST"]) def login(): This route takes in both GET and POST arguments to log the user in. The function first begins by clearing any previous member_id and clearing the session. If the argument is a POST, then the program will check to see if the user has entered a username and password. If either has not been entered, then an error HTML page will render and tell the user what the issue is. If the user has entered something into both fields, then the program runs a SQL query to get the entry where the entered username matches that of the one in the database. The next if-statement acts as validation. If there is no entry that has the entered username or the password attached to that username is typed in incorrectly (using the check_password_hash function), an error HTML page will be rendered telling the user that there is an issue with either the username or password. Next, the session is set to the member_id so the user can access their personal information while browsing the site (such as their review history). After successfully logging in, the user is redirected to the main page that renders only if the user is logged in. If the route is a GET, then the login.html page will be rendered.

19) @app.route("/logout") @login_requireddef logout(): When the log out button is pressed in the navigation bar, the session is cleared and then the user is redirected back to the login page. Unless they log in again, then they can no longer access all the features of the website that are only accessible when logged in.

STATIC FOLDER DETAIL: Within the static folder, favicons, images, a font, and the styles.css are found. The favicon is the little dog that appears in the tab. The various images are utilized as background images for certain pages within the site and are integrated within the styles.css file. The font was downloaded from the internet and was applied to give the site a more professional look. Within the styles.css file, all the design details cn be found. This includes styling all of the HTML files. Since integrating Bootstrap, Flask, and my own stylesheet was causing major rendering issues, I abandoned the Bootstrap integration and created all of the CSS myself using the different functionalities available. The styles.css includes a mix of tag modifications and classes that modify the style of the tag. There are also modifications of what seems to be the same page, such as multiple variations of the main page. This was done so I could slightly modify each page to be just right (think dimensions, alignment, etc.) for the purpose of each individual page.

TEMPLATES FOLDER DETAIL: Within the templates folder, all of the HTML files can be found that are rendered at various places within the application. The HTML files generally have a few types of purpose. Many of the HTML files either contain a "no" or "missing" or "error" or "empty" in the file name, which indicates that they are the pages that render when the user makes errors while interacting with the website (such as forgetting to fill a field, filling in a field incorrectly, not getting a desired result, etc.). Next, there are a few HTML files are static and simply allow the user to view the information or execute simple redirects to other pages within the application. An example of this would be the about_us.html file, which simply displays the text of the Yalieats story without any real opportunity for additional user interaction other than redirecting to other places in the website. Additonally, there are the pages that offer enhanced opportunity for user interaction. These are the pages that contain the forms and buttons to submit those forms. Finally, there are the pages tasked with displaying the results from the numerous SQL queries that are executed within the app.py file. These HTML pages integrate some simple Jinja in order to display these results or even display multiple results from a database query. For example, in filter_search_result.html, there is a Jinja for-loop that allows the page to display all of the restaurants that match the search criteria that the user entered with the filters. Jinja also allows these passed in values (passed into the render_template function in the functions in app.py) to be visually displayed using double curly braces {{}}.

HELPERS.PY DETAIL: The helpers.py file simply contains the login_required function that is called upon throughout the app.py file to ensure that cetain routes and pages can only be accessed if the user is logged in. This function stems from the CS50 Finance PSET in order to ensure the security and functionality within the Yalieats application.

REQUIREMENTS.TXT DETAIL: The requirements.txt lists the required libraries needed for the application to run. The cs50, Flask, and Flask-Session libraries are needed to run Yalieats.

YALIEATS.DB DETAIL: The yalieats.db database is the crucial bank of information that the entire program relies on. Within the database, there are three tables: restaurants, reviews, and members. These three tables have their own information and are linked to each other using keys integrated into the table formats. The table formats are as follows:

CREATE TABLE members (
    member_id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    first_name VARCHAR (255) NOT NULL,
    last_name VARCHAR (255) NOT NULL,
    email_address VARCHAR (255) NOT NULL,
    username VARCHAR (255) NOT NULL,
    password VARCHAR (255) NOT NULL);

CREATE TABLE sqlite_sequence(name,seq);

CREATE TABLE restaurants (
    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    restaurant_name VARCHAR (255) NOT NULL,
    address VARCHAR (255) NOT NULL,
    phone_number VARCHAR (255) NOT NULL,
    type_of_food VARCHAR (255) NOT NULL,
    on_snackpass VARCHAR (255) NOT NULL,
    restaurant_vibe VARCHAR (255) NOT NULL);

CREATE TABLE IF NOT EXISTS 'reviews' (
    review_id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    restaurant_id INTEGER NOT NULL,
    memberID INTEGER NOT NULL,
    price_rating INTEGER (255) NOT NULL,
    portion_size_rating INTEGER (255) NOT NULL,
    recommendation TEXT (255) NOT NULL,
    'overall_restaurant_rating'  INTEGER NOT NULL  , 'deliciousness_rating'  INTEGER NOT NULL  ,
    'review_text'  TEXT NOT NULL  ,
    FOREIGN KEY(restaurant_id) REFERENCES restaurants(id),
    FOREIGN KEY(memberID) REFERENCES members(member_id));

As seen in the schema for each of the tables, the reviews are linked to the members and the restaurants to allow reviews to be tied to both the person who submitted them (and then they can see their review history in the your_account.html page) and the restaurant they are for (then users can see the reviews and the respective ratings that members gave for the restaurants they search for or filter for within the application). I initially played around with the idea of using some sort of API for the restaurants table, but there were none that matched what I wanted, so I manually made my own. I used a website that had a master list of all the restaurants in the New Haven area and then searched up the address, phone_number, Snackpass status, and set other parameters of the restaurant based on what the general atmosphere of the place seemed to be. The current database has 212 complete entries that detail pretty much every single restaurant in New Haven. In the terminal window, I executed INSERT INTO commands for each entry until I got through the list. This master list of restaurants was also then used for the dropdown menus. I initially played with the idea of letting users type in the name of restaurants, but then realized that there was too much margin for error, so I exported the table as a CSV file to Google Sheets, got all the names, and made dropdown menu options for each of them. Tedious, but more user-friendly, which was one of my key goals in making this application because I would like to deploy it as an app that the Yale community can use.

SECURITY: Security concerns are always present when using any sort of web application, especially when personal information is involved. Yalieats implements basic security measures through a password hashing process (when registering, passwords are hashed and encrypted for security measures. In the database, password entries appear as lengthy jumbles of letters, numbers, and other characters), including the @login_required function to prevent non-members from jumping to pages that they shouldn't have access to, and keeping the Google Form for feedback within the Yale email organization.


CONCLUSION: The Yalieats program is a Flask web application that integrates Python, SQL, HTML, CSS, and Jinja to create a unique user experience that makes finding a local restaurant easier for Yale students. Through a series of SQL statements, form submissions, and button clicks, the member can explore through the application and access reviews, information about restaurants, submit reviews, and filter results to find the perfect place for any situation.
